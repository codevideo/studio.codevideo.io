import { IAction } from "@fullstackcraftllc/codevideo-types";

export const blankJavaScriptExampleActions: Array<IAction> = [
];

export const typingUnitTestExampleActions: Array<IAction> = [
    {
        "name": "file-explorer-create-file",
        "value": "text.txt"
    },
    {
        "name": "file-explorer-open-file",
        "value": "text.txt"
    },
    {
        "name": "editor-type",
        "value": "a"
    },
    {
        "name": "editor-type",
        "value": "b"
    },
    {
        "name": "editor-type",
        "value": "c"
    },
    {
        "name": "editor-type",
        "value": "d"
    },
    {
        "name": "editor-type",
        "value": "e"
    },
    {
        "name": "editor-type",
        "value": "f"
    },
    {
        "name": "editor-type",
        "value": "g"
    },
    {
        "name": "editor-type",
        "value": "h"
    },
    {
        "name": "editor-type",
        "value": "i"
    },
    {
        "name": "editor-type",
        "value": "j"
    },
    {
        "name": "editor-type",
        "value": "k"
    },
    {
        "name": "editor-type",
        "value": "l"
    },
    {
        "name": "editor-type",
        "value": "m"
    },
    {
        "name": "editor-type",
        "value": "n"
    },
    {
        "name": "editor-type",
        "value": "o"
    },
    {
        "name": "editor-type",
        "value": "p"
    },
    {
        "name": "editor-type",
        "value": "q"
    },
    {
        "name": "editor-type",
        "value": "r"
    },
    {
        "name": "editor-type",
        "value": "s"
    },
    {
        "name": "editor-type",
        "value": "t"
    },
    {
        "name": "editor-type",
        "value": "u"
    },
    {
        "name": "editor-type",
        "value": "v"
    },
    {
        "name": "editor-type",
        "value": "w"
    },
    {
        "name": "editor-type",
        "value": "x"
    },
    {
        "name": "editor-type",
        "value": "y"
    },
    {
        "name": "editor-type",
        "value": "z"
    },
    {
        "name": "editor-backspace",
        "value": "26"
    },
    {
        "name": "editor-type",
        "value": "a"
    },
    {
        "name": "editor-type",
        "value": "b"
    },
    {
        "name": "editor-type",
        "value": "c"
    },
    {
        "name": "editor-type",
        "value": "d"
    },
    {
        "name": "editor-type",
        "value": "e"
    },
    {
        "name": "editor-type",
        "value": "f"
    },
    {
        "name": "editor-type",
        "value": "g"
    },
    {
        "name": "editor-type",
        "value": "h"
    },
    {
        "name": "editor-type",
        "value": "i"
    },
    {
        "name": "editor-type",
        "value": "j"
    },
    {
        "name": "editor-type",
        "value": "k"
    },
    {
        "name": "editor-type",
        "value": "l"
    },
    {
        "name": "editor-type",
        "value": "m"
    },
    {
        "name": "editor-type",
        "value": "n"
    },
    {
        "name": "editor-type",
        "value": "o"
    },
    {
        "name": "editor-type",
        "value": "p"
    },
    {
        "name": "editor-type",
        "value": "q"
    },
    {
        "name": "editor-type",
        "value": "r"
    },
    {
        "name": "editor-type",
        "value": "s"
    },
    {
        "name": "editor-type",
        "value": "t"
    },
    {
        "name": "editor-type",
        "value": "u"
    },
    {
        "name": "editor-type",
        "value": "v"
    },
    {
        "name": "editor-type",
        "value": "w"
    },
    {
        "name": "editor-type",
        "value": "x"
    },
    {
        "name": "editor-type",
        "value": "y"
    },
    {
        "name": "editor-type",
        "value": "z"
    },
    {
        "name": "editor-backspace",
        "value": "26"
    },
    {
        "name": "editor-type",
        "value": "a"
    },
    {
        "name": "editor-type",
        "value": "b"
    },
    {
        "name": "editor-type",
        "value": "c"
    },
    {
        "name": "editor-type",
        "value": "d"
    },
    {
        "name": "editor-type",
        "value": "e"
    },
    {
        "name": "editor-type",
        "value": "f"
    },
    {
        "name": "editor-type",
        "value": "g"
    },
    {
        "name": "editor-type",
        "value": "h"
    },
    {
        "name": "editor-type",
        "value": "i"
    },
    {
        "name": "editor-type",
        "value": "j"
    },
    {
        "name": "editor-type",
        "value": "k"
    },
    {
        "name": "editor-type",
        "value": "l"
    },
    {
        "name": "editor-type",
        "value": "m"
    },
    {
        "name": "editor-type",
        "value": "n"
    },
    {
        "name": "editor-type",
        "value": "o"
    },
    {
        "name": "editor-type",
        "value": "p"
    },
    {
        "name": "editor-type",
        "value": "q"
    },
    {
        "name": "editor-type",
        "value": "r"
    },
    {
        "name": "editor-type",
        "value": "s"
    },
    {
        "name": "editor-type",
        "value": "t"
    },
    {
        "name": "editor-type",
        "value": "u"
    },
    {
        "name": "editor-type",
        "value": "v"
    },
    {
        "name": "editor-type",
        "value": "w"
    },
    {
        "name": "editor-type",
        "value": "x"
    },
    {
        "name": "editor-type",
        "value": "y"
    },
    {
        "name": "editor-type",
        "value": "z"
    },
    {
        "name": "editor-backspace",
        "value": "26"
    },
]

export const javaScriptExampleActions: Array<IAction> = [
    {
        "name": "author-speak-before",
        "value": "Let's learn how to use the console.log function in JavaScript!"
    },
    {
        "name": "author-speak-before",
        "value": "First, let's make our JavaScript file."
    },
    {
        "name": "file-explorer-create-file",
        "value": "src/index.js"
    },
    {
        "name": "file-explorer-open-file",
        "value": "src/index.js"
    },
    {
        "name": "author-speak-before",
        "value": "And let's get right into the editor."
    },
    {
        "name": "mouse-click-editor",
        "value": "1"
    },
    {
        "name": "editor-type",
        "value": "// index.js"
    },
    {
        "name": "editor-enter",
        "value": "1"
    },
    {
        "name": "author-speak-before",
        "value": "For starters, let's just print 'Hello world!' to the console."
    },
    {
        "name": "editor-type",
        "value": "console.log('Hello, world!');"
    },
    {
        "name": "author-speak-before",
        "value": "and if I wanted to write the value of some variable to the console, I could do that like so:"
    },
    {
        "name": "editor-backspace",
        "value": "29"
    },
    {
        "name": "editor-type",
        "value": "const myVariable = 5;"
    },
    {
        "name": "editor-enter",
        "value": "1"
    },
    {
        "name": "editor-type",
        "value": "console.log(myVariable);"
    },
    {
        "name": "author-speak-before",
        "value": "Now, when I run this code, I would expect the value of 'myVariable' to be printed to the console. Something like:"
    },
    {
        "name": "editor-type",
        "value": " // should log out '5'"
    },
    {
        "name": "author-speak-before",
        "value": "Console logging is simple, yet powerful and very useful!"
    }
];

export const functionalTerminalActions: Array<IAction> = [
    {
        "name": "author-speak-before",
        "value": "The CodeVideo framework features a 'sensible-enough' terminal including all commands that would be needed for a software course."
    },
    {
        "name": "author-speak-before",
        "value": "Currently the terminal supports the following commands: cat, cd, cp, echo, ls, mkdir, mv, pwd, touch, and tree"
    },
    {
        "name": "author-speak-before",
        "value": "Keep in mind our goal is not to rewrite an entire operating system but just provide the most common commands used in educational content :)."
    },
    {
        "name": "author-speak-before",
        "value": "So, let's open up a terminal and go through each of these commands.",
    },
    {
        "name": "terminal-open",
        "value": "1"
    },
    {
        "name": "author-speak-before",
        "value": "First is the classic echo command. This command simply prints out the arguments passed to it."
    },
    {
        "name": "terminal-type",
        "value": "echo 'Hello, world!'"
    },
    {
        "name": "terminal-enter",
        "value": "1"
    },
    { 
        "name": "author-speak-before", 
        "value": "Next, let's create a file with the touch command."
    },
    {
        "name": "terminal-type",
        "value": "touch my-file.txt"
    },
    {
        "name": "terminal-enter",
        "value": "1"
    },
    {
        "name": "author-speak-before",
        "value": "We can also create a directory with the mkdir command."
    },
    {
        "name": "terminal-type",
        "value": "mkdir my-directory"
    },
    {
        "name": "terminal-enter",
        "value": "1"
    },
    {
        "name": "author-speak-before",
        "value": "Now, let's list the contents of the directory with the ls command."
    },
    {
        "name": "terminal-type",
        "value": "ls"
    },
    {
        "name": "terminal-enter",
        "value": "1"
    },
    {
        "name": "author-speak-before",
        "value": "Now, let's move the file we created into the directory we just created."
    },
    {
        "name": "terminal-type",
        "value": "mv my-file.txt my-directory/my-file.txt"
    },
    {
        "name": "terminal-enter",
        "value": "1"
    },
    {
        "name": "author-speak-before",
        "value": "Let's list the contents of the directory again to see the file has been moved."
    },
    {
        "name": "terminal-type",
        "value": "ls my-directory"
    },
    {
        "name": "terminal-enter",
        "value": "1"
    },
    {
        "name": "author-speak-before",
        "value": "We can also move into directories with the cd command."
    },
    {
        "name": "terminal-type",
        "value": "cd my-directory"
    },
    {
        "name": "terminal-enter",
        "value": "1"
    },
    {
        "name": "author-speak-before",
        "value": "Note that the terminal's prompt has changed to reflect the current directory."
    },
    {
        "name": "author-speak-before",
        "value": "Likewise commands that rely on the current directory will now be executed in the new directory, for example the ls command."
    },
    {
        "name": "terminal-type",
        "value": "ls"
    },
    {
        "name": "terminal-enter",
        "value": "1"
    },
    {
        "name": "author-speak-before",
        "value": "Let's move back to the root directory with the cd command."
    },
    {
        "name": "terminal-type",
        "value": "cd .."
    },
    {
        "name": "terminal-enter",
        "value": "1"
    },
    {
        "name": "author-speak-before",
        "value": "And list the contents of the directory again to see we are back in the root directory."
    },
    {
        "name": "terminal-type",
        "value": "ls"
    },
    {
        "name": "terminal-enter",
        "value": "1"
    },
    {
        "name": "author-speak-before",
        "value": "We can also copy the file back to the root directory with the cp command."
    },
    {
        "name": "terminal-type",
        "value": "cp my-directory/my-file.txt ~/my-file.txt"
    },
    {
        "name": "terminal-enter",
        "value": "1"
    },
    {
        "name": "author-speak-before",
        "value": "And list the contents of the directory again to see the file has been copied."
    },
    {
        "name": "terminal-type",
        "value": "ls"
    },
    {
        "name": "terminal-enter",
        "value": "1"
    },
    {
        "name": "author-speak-before",
        "value": "We can also print the current working directory with the pwd command."
    },
    {
        "name": "terminal-type",
        "value": "pwd"
    },
    {
        "name": "terminal-enter",
        "value": "1"
    },
    {
        "name": "author-speak-before",
        "value": "We can print the contents of the file with the cat command."
    },
    {
        "name": "terminal-type",
        "value": "cat my-file.txt"
    },
    {
        "name": "terminal-enter",
        "value": "1"
    },
    {
        "name": "author-speak-before",
        "value": "And finally, we can print the directory structure with the tree command."
    },
    {
        "name": "terminal-type",
        "value": "tree"
    },
    {
        "name": "terminal-enter",
        "value": "1"
    },
    {
        "name": "author-speak-before",
        "value": "And that's it! These are the commands currently supported in the CodeVideo terminal."
    }
]

export const javascriptCreateRenameDeleteFileExampleActions: Array<IAction> = [
    {
        "name": "author-speak-before",
        "value": "Let's test CodeVideo's ability to create, rename, and delete files in JavaScript!"
    },
    {
        "name": "file-explorer-create-file",
        "value": "src/my-new-file.js"
    },
    {
        "name": "file-explorer-open-file",
        "value": "src/my-new-file.js"
    },
    {
        "name": "file-explorer-delete-file",
        "value": "src/my-new-file.js"
    }
];

export const mouseMovementExampleActions: Array<IAction> = [
    {
        "name": "author-speak-before",
        "value": "Let's test CodeVideo's ability to move the mouse to specific coordinates!"
    },
    // move mouse in a square 2x, starting at 200,200 - that means 8 actions
    {
        "name": "mouse-move",
        "value": "200,200"
    },
    {
        "name": "mouse-move",
        "value": "400,200"
    },
    {
        "name": "mouse-move",
        "value": "400,400"
    },
    {
        "name": "mouse-move",
        "value": "200,400"
    },
    {
        "name": "mouse-move",
        "value": "200,200"
    },
    {
        "name": "mouse-move",
        "value": "400,200"
    },
    {
        "name": "mouse-move",
        "value": "400,400"
    },
    {
        "name": "mouse-move",
        "value": "200,400"
    }

];

export const pythonExampleActions: Array<IAction> = [
    {
        "name": "author-speak-before",
        "value": "Let's learn how to use the print function in Python!"
    },
    {
        "name": "author-speak-before",
        "value": "First, let's make a Python file."
    },
    {
        "name": "file-explorer-create-file",
        "value": "main.py"
    },
    {
        "name": "file-explorer-open-file",
        "value": "main.py"
    },
    {
        "name": "author-speak-before",
        "value": "and let's print 'Hello world!' to the console."
    },
    {
        "name": "editor-type",
        "value": "print('Hello, world!')"
    },
    {
        "name": "author-speak-before",
        "value": "and if I wanted to write the value of some variable to the console, I could do that like so:"
    },
    {
        "name": "editor-backspace",
        "value": "22"
    },
    {
        "name": "editor-type",
        "value": "my_variable = 5"
    },
    {
        "name": "editor-enter",
        "value": "1"
    },
    {
        "name": "editor-type",
        "value": "print(my_variable)"
    },
    {
        "name": "author-speak-before",
        "value": "Now, when I run this code, I would expect the value of 'my_variable' to be printed to the console. Something like:"
    },
    {
        "name": "editor-enter",
        "value": "1"
    },
    {
        "name": "editor-type",
        "value": "# 5"
    },
    {
        "name": "author-speak-before",
        "value": "Console logging is simple, yet powerful and very useful!"
    },
    {
        "name": "author-speak-before",
        "value": "Well done, lets save our file."
    },
    {
        "name": "editor-save",
        "value": "main.py"
    },
    {
        "name": "author-speak-before",
        "value": "Saved!"
    },
    {
        "name": "author-speak-before",
        "value": "Oh... and I've just realized... this file looks a bit strange... let's add the python shebang to the top of the file."
    },
    {
        "name": "editor-arrow-up",
        "value": "4"
    },
    {
        "name": "editor-command-left",
        "value": "1"
    },
    {
        "name": "editor-enter",
        "value": "1"
    },
    {
        "name": "editor-arrow-up",
        "value": "1"
    },
    {
        "name": "editor-type",
        "value": "#!/usr/bin/env python"
    },
    {
        "name": "editor-enter",
        "value": "1"
    },
    {
        "name": "author-speak-before",
        "value": "Ah...much better!"
    },
    {
        "name": "author-speak-before",
        "value": "Let's save the file again."
    },
    {
        "name": "editor-save",
        "value": "main.py"
    },
    {
        "name": "author-speak-before",
        "value": "Saved!"
    },
    {
        "name": "author-speak-before",
        "value": "Now, let's open a terminal and run this file..."
    },
    {
        "name": "terminal-open",
        "value": "1"
    },
    {
        "name": "terminal-type",
        "value": "python main.py"
    },
    {
        "name": "terminal-enter",
        "value": "1"
    },
    {
        "name": "terminal-type",
        "value": "Hello, world!"
    },
    {
        "name": "author-speak-before",
        "value": "Perfect, our code is working as expected!"
    }
];

export const cSharpExampleActions: Array<IAction> = [
    {
        "name": "author-speak-before",
        "value": "Let's learn how to use the Console.WriteLine function in C sharp!"
    },
    {
        "name": "author-speak-before",
        "value": "First, to make it clear that this is a C sharp file, I'll just put a comment here"
    },
    {
        "name": "editor-type",
        "value": "// MyClass.cs"
    },
    {
        "name": "editor-enter",
        "value": "2"
    },
    {
        "name": "author-speak-before",
        "value": "Then, we'll need to use System, so let's add that to the top of the file."
    },
    {
        "name": "editor-type",
        "value": "using System;"
    },
    {
        "name": "editor-enter",
        "value": "1"
    },
    {
        "name": "author-speak-before",
        "value": "Next, we'll need to create a name space and class declaration. Let's just use 'MyNamespace' and 'MyClass' for now."
    },
    {
        "name": "editor-type",
        "value": "namespace MyNamespace"
    },
    {
        "name": "editor-enter",
        "value": "1"
    },
    {
        "name": "editor-type",
        "value": "{"
    },
    {
        "name": "editor-enter",
        "value": "2"
    },
    {
        "name": "editor-arrow-up",
        "value": "1"
    },
    {
        "name": "editor-type",
        "value": "    class MyClass"
    },
    {
        "name": "editor-enter",
        "value": "1"
    },
    {
        "name": "editor-type",
        "value": "    {"
    },
    {
        "name": "editor-enter",
        "value": "1"
    },
    {
        "name": "author-speak-before",
        "value": "We'll need a main method to run our code, so let's add that as well."
    },
    {
        "name": "editor-type",
        "value": "        public static void Main(string[] args)"
    },
    {
        "name": "editor-enter",
        "value": "1"
    },
    {
        "name": "editor-type",
        "value": "        {"
    },
    {
        "name": "editor-enter",
        "value": "1"
    },
    {
        "name": "author-speak-before",
        "value": "Now let's print 'Hello world!' to the console."
    },
    {
        "name": "editor-type",
        "value": '            Console.WriteLine("Hello, world!");'
    },
    {
        "name": "editor-enter",
        "value": "1"
    },
    {
        "name": "editor-type",
        "value": "        }"
    },
    {
        "name": "editor-enter",
        "value": "1"
    },
    {
        "name": "editor-type",
        "value": "    }"
    },
    {
        "name": "editor-enter",
        "value": "1"
    },
    {
        "name": "editor-type",
        "value": "}"
    },
    {
        "name": "editor-arrow-up",
        "value": "3"
    },
    {
        "name": "author-speak-before",
        "value": "and if I wanted to write the value of some variable to the console, I could do that like so:"
    },
    {
        "name": "editor-backspace",
        "value": "37"
    },
    {
        "name": "editor-type",
        "value": "            int myVariable = 5;"
    },
    {
        "name": "editor-enter",
        "value": "1"
    },
    {
        "name": "editor-type",
        "value": "            Console.WriteLine(myVariable);"
    },
    {
        "name": "author-speak-before",
        "value": "Now, when I run this code, I would expect the value of 'myVariable' to be printed to the console. Something like:"
    },
    {
        "name": "editor-enter",
        "value": "1"
    },
    {
        "name": "editor-type",
        "value": "// 5"
    },
    {
        "name": "author-speak-before",
        "value": "Console logging is simple, yet powerful and very useful!"
    }
];

export const goLangExampleActions: Array<IAction> = [
    {
        "name": "author-speak-before",
        "value": "Let's learn how to use the fmt.Println function in Go!"
    },
    {
        "name": "author-speak-before",
        "value": "First, to make it clear that this is a Go file, I'll just put a comment here"
    },
    {
        "name": "editor-type",
        "value": "// main.go"
    },
    {
        "name": "editor-enter",
        "value": "1"
    },
    {
        "name": "author-speak-before",
        "value": "First, we'll need to declare the main package, and then the main function."
    },
    {
        "name": "editor-type",
        "value": "package main"
    },
    {
        "name": "editor-enter",
        "value": "2"
    },
    {
        "name": "author-speak-before",
        "value": "And we'll need the fmt package to use the Println function."
    },
    {
        "name": "editor-type",
        "value": 'import "fmt"'
    },
    {
        "name": "editor-enter",
        "value": "1"
    },
    {
        "name": "editor-type",
        "value": "func main() {"
    },
    {
        "name": "editor-enter",
        "value": "1"
    },
    {
        "name": "author-speak-before",
        "value": "and let's just print 'Hello world!' to the console."
    },
    {
        "name": "editor-type",
        "value": '    fmt.Println("Hello, world!")'
    },
    {
        "name": "editor-enter",
        "value": "1"
    },
    {
        "name": "editor-type",
        "value": "}"
    },
    {
        "name": "editor-arrow-up",
        "value": "1"
    },
    {
        "name": "editor-command-right",
        "value": "1"
    },
    {
        "name": "author-speak-before",
        "value": "and if I wanted to write the value of some variable to the console, I could do that like so:"
    },
    {
        "name": "editor-backspace",
        "value": "32"
    },
    {
        "name": "editor-type",
        "value": "    myVariable := 5"
    },
    {
        "name": "editor-enter",
        "value": "1"
    },
    {
        "name": "editor-type",
        "value": "    fmt.Println(myVariable)"
    },
    {
        "name": "author-speak-before",
        "value": "Now, when I run this code, I would expect the value of 'myVariable' to be printed to the console. Something like:"
    },
    {
        "name": "editor-enter",
        "value": "1"
    },
    {
        "name": "editor-type",
        "value": "    // 5"
    },
    {
        "name": "author-speak-before",
        "value": "Console logging is simple, yet powerful and very useful!"
    }
];

export const advancedRustExampleActions: Array<IAction> = [
    {
        "name": "author-speak-before",
        "value": "Hi everyone! Today I wanted to make this video to showcase the powers of my codevideo framework with a much more complex example."
    },
    {
        "name": "author-speak-before",
        "value": "We'll be exploring an elegant solution in Rust that demonstrates the power of recursion combined with memoization."
    },
    {
        "name": "author-speak-before",
        "value": "This particular problem was from day 11 of this year's Advent of Code - the challenge that came out on December 11th."
    },
    {
        "name": "author-speak-before",
        "value": "To get started, let's make a main.rs file in the src directory."
    },
    {
        "name": "file-explorer-create-folder",
        "value": "src"
    },
    {
        "name": "file-explorer-create-file",
        "value": "src/main.rs"
    },
    {
        "name": "file-explorer-open-file",
        "value": "src/main.rs"
    },
    {
        "name": "author-speak-before",
        "value": "Let's take a look at the problem now, titled 'Plutonian Pebbles'. We need to simulate some strange stones that change every time we blink..."
    },
    {
        "name": "external-browser",
        "value": "https://adventofcode.com/2024/day/11"
    },
    {
        "name": "author-speak-before",
        "value": "We can also see there are three rules for how the stones change. Let's start by implementing a naive solution for Part 1..."
    },
    {
        "name": "editor-type",
        "value": "fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {"
    },
    {
        "name": "editor-enter",
        "value": "1"
    },
    {
        "name": "editor-type",
        "value": "    let mut new_stones = Vec::new();"
    },
    {
        "name": "editor-enter",
        "value": "2"
    },
    {
        "name": "editor-type",
        "value": "    for stone in stone_engravings {"
    },
    {
        "name": "editor-enter",
        "value": "1"
    },
    {
        "name": "author-speak-before",
        "value": "The rules are pretty straightforward. For each stone, we need to check three conditions..."
    },
    {
        "name": "editor-type",
        "value": "        if stone == 0 {"
    },
    {
        "name": "editor-enter",
        "value": "1"
    },
    {
        "name": "editor-type",
        "value": "            // Rule 1: stone = 0 -> replaced by stone marked 1"
    },
    {
        "name": "editor-enter",
        "value": "1"
    },
    {
        "name": "editor-type",
        "value": "            new_stones.push(1);"
    },
    {
        "name": "editor-enter",
        "value": "1"
    },
    {
        "name": "editor-type",
        "value": "        } else {"
    },
    {
        "name": "author-speak-before",
        "value": "So here it's pretty straightforward, if the stone is engraved with 0 it becomes engraved with a 1"
    },
    {
        "name": "editor-enter",
        "value": "1"
    },
    {
        "name": "editor-type",
        "value": "            let stone_str = stone.to_string();"
    },
    {
        "name": "editor-enter",
        "value": "1"
    },
    {
        "name": "editor-type",
        "value": "            let stone_len = stone_str.len();"
    },
    {
        "name": "editor-enter",
        "value": "2"
    },
    {
        "name": "editor-type",
        "value": "            if stone_len % 2 == 0 {"
    },
    {
        "name": "editor-enter",
        "value": "1"
    },
    {
        "name": "editor-type",
        "value": "                // Rule 2: split into two stones"
    },
    {
        "name": "editor-enter",
        "value": "1"
    },
    {
        "name": "editor-type",
        "value": "                let half = stone_len / 2;"
    },
    {
        "name": "editor-enter",
        "value": "1"
    },
    {
        "name": "editor-type",
        "value": "                let left_stone = stone_str[0..half].parse::<i64>().unwrap();"
    },
    {
        "name": "editor-enter",
        "value": "1"
    },
    {
        "name": "editor-type",
        "value": "                let right_stone = stone_str[half..].parse::<i64>().unwrap();"
    },
    {
        "name": "editor-enter",
        "value": "2"
    },
    {
        "name": "editor-type",
        "value": "                new_stones.push(left_stone);"
    },
    {
        "name": "editor-enter",
        "value": "1"
    },
    {
        "name": "editor-type",
        "value": "                new_stones.push(right_stone);"
    },
    {
        "name": "editor-enter",
        "value": "1"
    },
    {
        "name": "author-speak-before",
        "value": "And for this else block, if a stone has an even number of digits, we split it in two where the \"left\" stone becomes the first half of the original stone, and the right stone becomes the \"right\" half of the original stone."
    },
    {
        "name": "editor-type",
        "value": "            } else {"
    },
    {
        "name": "editor-enter",
        "value": "1"
    },
    {
        "name": "editor-type",
        "value": "                // Rule 3: multiply by 2024"
    },
    {
        "name": "editor-enter",
        "value": "1"
    },
    {
        "name": "editor-type",
        "value": "                new_stones.push(stone * 2024);"
    },
    {
        "name": "editor-enter",
        "value": "1"
    },
    {
        "name": "editor-type",
        "value": "            }"
    },
    {
        "name": "author-speak-before",
        "value": "And finally, if none of the other rules applied, we multiply the stone by 2024"
    },
    {
        "name": "editor-enter",
        "value": "1"
    },
    {
        "name": "editor-type",
        "value": "        }"
    },
    {
        "name": "editor-enter",
        "value": "1"
    },
    {
        "name": "editor-type",
        "value": "    }"
    },
    {
        "name": "editor-enter",
        "value": "2"
    },
    {
        "name": "editor-type",
        "value": "    new_stones"
    },
    {
        "name": "author-speak-before",
        "value": "And then of course we return the new stones."
    },
    {
        "name": "editor-enter",
        "value": "1"
    },
    {
        "name": "editor-type",
        "value": "}"
    },
    {
        "name": "author-speak-before",
        "value": "This naive implementation works fine for Part 1, where we only need to blink 25 times. Lets set up a part 1 function and run it."
    },
    {
        "name": "editor-enter",
        "value": "2"
    },
    {
        "name": "editor-type",
        "value": "pub fn run_part_one() -> std::io::Result<()> {"
    },
    {
        "name": "editor-enter",
        "value": "1"
    },
    {
        "name": "editor-type",
        "value": "    let input = read_lines_as_int_arrays(\"src/day_11/input.txt\", \"\")?;"
    },
    {
        "name": "author-speak-before",
        "value": "We'll read in the single line puzzle input as an array."
    },
    {
        "name": "editor-enter",
        "value": "2"
    },
    {
        "name": "editor-type",
        "value": "    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();"
    },
    {
        "name": "author-speak-before",
        "value": "Then convert that first array to a vec of 64 byte integers."
    },
    {
        "name": "editor-enter",
        "value": "2"
    },
    {
        "name": "editor-type",
        "value": "    let mut stone_engravings = initial_stone_engravings.clone();"
    },
    {
        "name": "author-speak-before",
        "value": "We'll make a mutable clone of the initial stone engravings."
    },
    {
        "name": "editor-enter",
        "value": "1"
    },
    {
        "name": "editor-type",
        "value": "    for _ in 0..25 {"
    },
    {
        "name": "editor-enter",
        "value": "1"
    },
    {
        "name": "editor-type",
        "value": "        stone_engravings = execute_blink(stone_engravings);"
    },
    {
        "name": "editor-enter",
        "value": "1"
    },
    {
        "name": "editor-type",
        "value": "    }"
    },
    {
        "name": "editor-enter",
        "value": "1"
    },
    {
        "name": "author-speak-before",
        "value": "And then we can execute the blink 25 times!"
    },
    {
        "name": "author-speak-before",
        "value": "We can then finally log out the solution."
    },
    {
        "name": "editor-type",
        "value": "    println!(\"Count of stones after 25 blinks: {}\", stone_engravings.len());"
    },
    {
        "name": "editor-enter",
        "value": "1"
    },
    {
        "name": "editor-type",
        "value": "    Ok(())"
    },
    {
        "name": "editor-enter",
        "value": "1"
    },
    {
        "name": "editor-type",
        "value": "}"
    },
    {
        "name": "author-speak-before",
        "value": "Now, we could have just pasted in the puzzle input directly and converted to an array, but that's not so elegant, so let's go up to the top of the file and implement this read lines as int arrays function."
    },
    {
        "name": "editor-arrow-up",
        "value": "50"
    },
    {
        "name": "editor-arrow-left",
        "value": "1"
    },
    {
        "name": "editor-enter",
        "value": "3"
    },
    {
        "name": "editor-arrow-up",
        "value": "3"
    },
    {
        "name": "author-speak-before",
        "value": "We need to import from fs, io, and path libraries."
    },
    {
        "name": "editor-type",
        "value": "use std::fs::File;"
    },
    {
        "name": "editor-enter",
        "value": "1"
    },
    {
        "name": "editor-type",
        "value": "use std::io::{self, BufRead, BufReader};"
    },
    {
        "name": "editor-enter",
        "value": "1"
    },
    {
        "name": "editor-type",
        "value": "use std::path::Path;"
    },
    {
        "name": "editor-enter",
        "value": "2"
    },
    {
        "name": "author-speak-before",
        "value": "We'll start by importing the necessary modules. We need File for opening files, io utilities for buffered reading, and Path for handling file paths."
    },
    {
        "name": "editor-type",
        "value": "fn read_lines_as_int_arrays<P>(filename: P, sep: &str) -> io::Result<Vec<Vec<i32>>>"
    },
    {
        "name": "editor-enter",
        "value": "1"
    },
    {
        "name": "editor-type",
        "value": "where"
    },
    {
        "name": "editor-enter",
        "value": "1"
    },
    {
        "name": "editor-type",
        "value": "    P: AsRef<Path>,"
    },
    {
        "name": "editor-enter",
        "value": "1"
    },
    {
        "name": "editor-type",
        "value": "{"
    },
    {
        "name": "author-speak-before",
        "value": "Our function will be generic over any type P that can be referenced as a Path. This gives us flexibility in what types of path arguments we can accept."
    },
    {
        "name": "editor-enter",
        "value": "1"
    },
    {
        "name": "editor-type",
        "value": "    let file = File::open(filename)?;"
    },
    {
        "name": "author-speak-before",
        "value": "We open the file using the question mark operator, which will return early with an error if the file can't be opened."
    },
    {
        "name": "editor-enter",
        "value": "1"
    },
    {
        "name": "editor-type",
        "value": "    let reader = BufReader::new(file);"
    },
    {
        "name": "author-speak-before",
        "value": "We wrap the file in a BufReader for efficient reading. This gives us buffered reading capabilities which are much more efficient than reading one byte at a time."
    },
    {
        "name": "editor-enter",
        "value": "1"
    },
    {
        "name": "editor-type",
        "value": "    let lines: Vec<Result<String, io::Error>> = reader.lines().collect();"
    },
    {
        "name": "author-speak-before",
        "value": "We collect all lines into a vector. Note that each line is actually a Result, since reading can fail at any point."
    },
    {
        "name": "editor-enter",
        "value": "1"
    },
    {
        "name": "editor-type",
        "value": "    let mut int_arrays: Vec<Vec<i32>> = Vec::new();"
    },
    {
        "name": "author-speak-before",
        "value": "We'll create a vector to store our processed integer arrays."
    },
    {
        "name": "editor-enter",
        "value": "1"
    },
    {
        "name": "editor-type",
        "value": "    // split each line by the passed in sep and parse each element as an integer"
    },
    {
        "name": "editor-enter",
        "value": "1"
    },
    {
        "name": "editor-type",
        "value": "    for line in lines {"
    },
    {
        "name": "editor-enter",
        "value": "1"
    },
    {
        "name": "editor-type",
        "value": "        let line: String = line?;"
    },
    {
        "name": "author-speak-before",
        "value": "For each line, we use the question mark operator to handle any potential reading errors."
    },
    {
        "name": "editor-enter",
        "value": "1"
    },
    {
        "name": "editor-type",
        "value": "        let int_array: Vec<i32> = line.split(sep).map(|x| x.parse::<i32>().unwrap()).collect();"
    },
    {
        "name": "author-speak-before",
        "value": "We split each line by the separator, then parse each piece into an integer. Note that we're using unwrap here, which means this function will panic if it encounters any non-integer values."
    },
    {
        "name": "editor-enter",
        "value": "1"
    },
    {
        "name": "editor-type",
        "value": "        int_arrays.push(int_array);"
    },
    {
        "name": "editor-enter",
        "value": "1"
    },
    {
        "name": "editor-type",
        "value": "    }"
    },
    {
        "name": "editor-enter",
        "value": "1"
    },
    {
        "name": "editor-type",
        "value": "    Ok(int_arrays)"
    },
    {
        "name": "author-speak-before",
        "value": "Finally, we wrap our vector of integer arrays in Ok and return it."
    },
    {
        "name": "editor-enter",
        "value": "1"
    },
    {
        "name": "editor-type",
        "value": "}"
    },
    {
        "name": "editor-enter",
        "value": "2"
    },
    {
        "name": "author-speak-before",
        "value": "We'll create a main function to call the run part one function."
    },
    {
        "name": "editor-type",
        "value": "fn main() {"
    },
    {
        "name": "editor-enter",
        "value": "1"
    },
    {
        "name": "editor-type",
        "value": "    run_part_one();"
    },
    {
        "name": "editor-enter",
        "value": "1"
    },
    {
        "name": "editor-type",
        "value": "}"
    },
    {
        "name": "author-speak-before",
        "value": "And let's run this with cargo run:"
    },
    {
        "name": "mouse-click-terminal",
        "value": "1"
    },
    {
        "name": "terminal-type",
        "value": "cargo run"
    },
    {
        "name": "terminal-enter",
        "value": "1"
    },
    {
        "name": "mouse-click-editor",
        "value": "1"
    },
    {
        "name": "author-speak-before",
        "value": "However, when we try to use this approach for Part 2, which requires 75 blinks, we run into quite a problem. The number of stones grows exponentially the more we blink, and even when I was running this on my own M3 Max Mac, the calculations becomes intractable after around 40 to 45 blinks."
    },
    {
        "name": "author-speak-before",
        "value": "It's time we implement a more elegant, optimized, and efficient solution using recursion and memoization."
    },
    {
        "name": "editor-enter",
        "value": "2"
    },
    {
        "name": "author-speak-before",
        "value": "Let's get started by going to the top of the file and importing the HashMap package. We'll need this to keep track of our memoized stone engravings."
    },
    {
        "name": "editor-arrow-up",
        "value": "47"
    },
    {
        "name": "editor-command-left",
        "value": "1"
    },
    {
        "name": "editor-enter",
        "value": "1"
    },
    {
        "name": "editor-arrow-up",
        "value": "1"
    },
    {
        "name": "editor-type",
        "value": "use std::collections::HashMap;"
    },
    {
        "name": "editor-arrow-down",
        "value": "4"
    },
    {
        "name": "editor-enter",
        "value": "2"
    },
    {
        "name": "editor-arrow-up",
        "value": "1"
    },
    {
        "name": "author-speak-before",
        "value": "We can then define MemoKey and MemoMap types."
    },
    {
        "name": "editor-type",
        "value": "type MemoKey = (i64, usize);  // (stone_value, blinks_remaining)"
    },
    {
        "name": "editor-enter",
        "value": "1"
    },
    {
        "name": "editor-type",
        "value": "type MemoMap = HashMap<MemoKey, usize>;"
    },
    {
        "name": "author-speak-before",
        "value": "The reason we can memoize according to blinks is because the resulting stone from any given stone will always be the same - you can take a given stone, whether it be 0, 1, 2, 3 or whatever - and you immediately know any other stone you see from that point on will have the same exact 'production' of further stones... so to speak."
    },
    {
        "name": "editor-arrow-down",
        "value": "100"
    },
    {
        "name": "editor-enter",
        "value": "1"
    },
    {
        "name": "author-speak-before",
        "value": "So let's get started with the implementation."
    },
    {
        "name": "editor-type",
        "value": "fn count_stones_recursive(stone: i64, blinks: usize, memo: &mut MemoMap) -> usize {"
    },
    {
        "name": "author-speak-before",
        "value": "This new function will take the current stone engraving we are looking at, the number of blinks we are at, and the memoized map of stone engraving and blinks remaining."
    },
    {
        "name": "editor-enter",
        "value": "1"
    },
    {
        "name": "editor-type",
        "value": "    if blinks == 0 { return 1; }"
    },
    {
        "name": "editor-enter",
        "value": "2"
    },
    {
        "name": "editor-type",
        "value": "    let key = (stone, blinks);"
    },
    {
        "name": "editor-enter",
        "value": "1"
    },
    {
        "name": "editor-type",
        "value": "    if let Some(&count) = memo.get(&key) { return count; }"
    },
    {
        "name": "editor-enter",
        "value": "2"
    },
    {
        "name": "editor-type",
        "value": "    let result = if stone == 0 {"
    },
    {
        "name": "author-speak-before",
        "value": "This is where a major optimization gain is - if we've already seen this stone and blinks combo, we can immediately return the count that this number of blinks results in for this stone!"
    },
    {
        "name": "editor-enter",
        "value": "1"
    },
    {
        "name": "editor-type",
        "value": "        count_stones_recursive(1, blinks - 1, memo)"
    },
    {
        "name": "editor-enter",
        "value": "1"
    },
    {
        "name": "editor-type",
        "value": "    } else {"
    },
    {
        "name": "editor-enter",
        "value": "1"
    },
    {
        "name": "editor-type",
        "value": "        let digit_count = stone.to_string().len();"
    },
    {
        "name": "editor-enter",
        "value": "1"
    },
    {
        "name": "editor-type",
        "value": "        if digit_count % 2 == 0 {"
    },
    {
        "name": "editor-enter",
        "value": "1"
    },
    {
        "name": "editor-type",
        "value": "            let stone_str = stone.to_string();"
    },
    {
        "name": "editor-enter",
        "value": "1"
    },
    {
        "name": "editor-type",
        "value": "            let half = digit_count / 2;"
    },
    {
        "name": "editor-enter",
        "value": "1"
    },
    {
        "name": "editor-type",
        "value": "            let left = stone_str[..half].parse::<i64>().unwrap();"
    },
    {
        "name": "editor-enter",
        "value": "1"
    },
    {
        "name": "editor-type",
        "value": "            let right = stone_str[half..].parse::<i64>().unwrap();"
    },
    {
        "name": "editor-enter",
        "value": "2"
    },
    {
        "name": "editor-type",
        "value": "            count_stones_recursive(left, blinks - 1, memo) +"
    },
    {
        "name": "editor-enter",
        "value": "1"
    },
    {
        "name": "editor-type",
        "value": "            count_stones_recursive(right, blinks - 1, memo)"
    },
    {
        "name": "editor-enter",
        "value": "1"
    },
    {
        "name": "editor-type",
        "value": "        } else {"
    },
    {
        "name": "editor-enter",
        "value": "1"
    },
    {
        "name": "editor-type",
        "value": "            count_stones_recursive(stone * 2024, blinks - 1, memo)"
    },
    {
        "name": "editor-enter",
        "value": "1"
    },
    {
        "name": "editor-type",
        "value": "        }"
    },
    {
        "name": "editor-enter",
        "value": "1"
    },
    {
        "name": "editor-type",
        "value": "    };"
    },
    {
        "name": "editor-enter",
        "value": "2"
    },
    {
        "name": "editor-type",
        "value": "    memo.insert(key, result);"
    },
    {
        "name": "editor-enter",
        "value": "1"
    },
    {
        "name": "editor-type",
        "value": "    result"
    },
    {
        "name": "editor-enter",
        "value": "1"
    },
    {
        "name": "editor-type",
        "value": "}"
    },
    {
        "name": "author-speak-before",
        "value": "Now let's use this optimized solution to solve Part 2 of the challenge..."
    },
    {
        "name": "editor-arrow-up",
        "value": "28"
    },
    {
        "name": "author-speak-before",
        "value": "We'll comment out part one here..."
    },
    {
        "name": "editor-type",
        "value": "//"
    },
    {
        "name": "editor-command-right",
        "value": "1"
    },
    {
        "name": "editor-enter",
        "value": "1"
    },
    {
        "name": "editor-type",
        "value": "    run_part_two();"
    },
    {
        "name": "author-speak-before",
        "value": "And call run part two."
    },
    {
        "name": "editor-arrow-down",
        "value": "50"
    },
    {
        "name": "author-speak-before",
        "value": "And run part two looks like:"
    },
    {
        "name": "editor-enter",
        "value": "2"
    },
    {
        "name": "editor-type",
        "value": "pub fn run_part_two() -> std::io::Result<()> {"
    },
    {
        "name": "editor-enter",
        "value": "1"
    },
    {
        "name": "editor-type",
        "value": "    let input = read_lines_as_int_arrays(\"src/day_11/input.txt\", \"\")?;"
    },
    {
        "name": "editor-enter",
        "value": "2"
    },
    {
        "name": "editor-type",
        "value": "    let initial_stones: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();"
    },
    {
        "name": "editor-enter",
        "value": "1"
    },
    {
        "name": "editor-type",
        "value": "    let blinks = 75;"
    },
    {
        "name": "editor-enter",
        "value": "2"
    },
    {
        "name": "author-speak-before",
        "value": "Here's where further elegance shines through. Instead of simulating each blink step by step, we're going to use our memoized recursive function to calculate the total stones efficiently. We can give our map function the desired number of blinks directly."
    },
    {
        "name": "editor-type",
        "value": "    let mut memo = HashMap::new();"
    },
    {
        "name": "editor-enter",
        "value": "2"
    },
    {
        "name": "editor-type",
        "value": "    let total: usize = initial_stones.iter()"
    },
    {
        "name": "editor-enter",
        "value": "1"
    },
    {
        "name": "editor-type",
        "value": "        .map(|&stone| {"
    },
    {
        "name": "editor-enter",
        "value": "1"
    },
    {
        "name": "editor-type",
        "value": "            count_stones_recursive(stone, blinks, &mut memo)"
    },
    {
        "name": "editor-enter",
        "value": "1"
    },
    {
        "name": "editor-type",
        "value": "        })"
    },
    {
        "name": "editor-enter",
        "value": "1"
    },
    {
        "name": "editor-type",
        "value": "        .sum();"
    },
    {
        "name": "editor-enter",
        "value": "2"
    },
    {
        "name": "editor-type",
        "value": "    println!(\"Total stones after {} blinks: {}\", blinks, total);"
    },
    {
        "name": "editor-enter",
        "value": "2"
    },
    {
        "name": "editor-type",
        "value": "    Ok(())"
    },
    {
        "name": "editor-enter",
        "value": "1"
    },
    {
        "name": "editor-type",
        "value": "}"
    },
    {
        "name": "author-speak-before",
        "value": "Now, let's run this optimized solution and see how it performs..."
    },
    {
        "name": "author-speak-before",
        "value": "And let's run this with cargo run:"
    },
    {
        "name": "mouse-click-terminal",
        "value": "1"
    },
    {
        "name": "terminal-type",
        "value": "cargo run"
    },
    {
        "name": "terminal-enter",
        "value": "1"
    },
    {
        "name": "author-speak-before",
        "value": "Even with 75 blinks, our memoized solution calculates the result almost instantly! The answer, or rather, the final count of stones, is over 218 trillion! Something that couldn't be done quickly on even the craziest of hardware if done via brute force and storing all the stones in an array like our naive approach in part 1. "
    },
    {
        "name": "author-speak-before",
        "value": "This puzzle is a perfect example of how some smart algorithmic choices can solve problems that would be completely intractable with a naive approach."
    },
    {
        "name": "author-speak-before",
        "value": "Let's quickly review why this solution is so much more efficient..."
    },
    {
        "name": "author-speak-before",
        "value": "Again, the naive solution would need to store and process an exponentially growing number of stones. With 75 blinks, we'd need to handle over 218 trillion stones in memory! You'd need some serious hardware to do that!"
    },
    {
        "name": "author-speak-before",
        "value": "But our memoized solution just needs to store the count for each unique combination of stone value and remaining blinks. This dramatically reduces both memory usage and computation time."
    },
    {
        "name": "author-speak-before",
        "value": "This optimization technique is particularly powerful because it takes advantage of the problem's structure - the fact that any given stone will always produce the same result after a certain number of blinks."
    },
    {
        "name": "author-speak-before",
        "value": "And that wraps up our exploration this elegant solution in Rust! Thanks for watching - I hope this helped demonstrate the power of careful algorithmic choices and how you can implement them in Rust."
    }
]